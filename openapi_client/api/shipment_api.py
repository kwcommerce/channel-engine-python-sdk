# coding: utf-8

"""
    ChannelEngine Merchant API

    ChannelEngine API for merchants

    The version of the OpenAPI document: 2.14.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from datetime import datetime
from pydantic import Field, StrictBytes, StrictInt, StrictStr
from typing import List, Optional, Union
from typing_extensions import Annotated
from openapi_client.models.api_response import ApiResponse
from openapi_client.models.collection_of_merchant_shipment_label_carrier_response import CollectionOfMerchantShipmentLabelCarrierResponse
from openapi_client.models.collection_of_merchant_shipment_response import CollectionOfMerchantShipmentResponse
from openapi_client.models.merchant_channel_label_shipment_request import MerchantChannelLabelShipmentRequest
from openapi_client.models.merchant_shipment_label_carrier_request import MerchantShipmentLabelCarrierRequest
from openapi_client.models.merchant_shipment_request import MerchantShipmentRequest
from openapi_client.models.merchant_shipment_tracking_request import MerchantShipmentTrackingRequest
from openapi_client.models.shipment_fulfillment_type import ShipmentFulfillmentType

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class ShipmentApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def shipment_create(
        self,
        merchant_shipment_request: Optional[MerchantShipmentRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse:
        """Creates shipments

        Marks an order as fully or partially shipped, based on the order line and quantity input.<br />Indicate the **Stock location ID** if you make use of multiple stock locations.

        :param merchant_shipment_request:
        :type merchant_shipment_request: MerchantShipmentRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._shipment_create_serialize(
            merchant_shipment_request=merchant_shipment_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "ApiResponse",
            '400': "ApiResponse",
            '404': "ApiResponse",
            '409': "ApiResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def shipment_create_with_http_info(
        self,
        merchant_shipment_request: Optional[MerchantShipmentRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ApiResponse]:
        """Creates shipments

        Marks an order as fully or partially shipped, based on the order line and quantity input.<br />Indicate the **Stock location ID** if you make use of multiple stock locations.

        :param merchant_shipment_request:
        :type merchant_shipment_request: MerchantShipmentRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._shipment_create_serialize(
            merchant_shipment_request=merchant_shipment_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "ApiResponse",
            '400': "ApiResponse",
            '404': "ApiResponse",
            '409': "ApiResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def shipment_create_without_preload_content(
        self,
        merchant_shipment_request: Optional[MerchantShipmentRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Creates shipments

        Marks an order as fully or partially shipped, based on the order line and quantity input.<br />Indicate the **Stock location ID** if you make use of multiple stock locations.

        :param merchant_shipment_request:
        :type merchant_shipment_request: MerchantShipmentRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._shipment_create_serialize(
            merchant_shipment_request=merchant_shipment_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "ApiResponse",
            '400': "ApiResponse",
            '404': "ApiResponse",
            '409': "ApiResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _shipment_create_serialize(
        self,
        merchant_shipment_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if merchant_shipment_request is not None:
            _body_params = merchant_shipment_request


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json-patch+json', 
                        'application/json', 
                        'application/*+json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'apiKey'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/shipments',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def shipment_create_for_channel_method(
        self,
        merchant_channel_label_shipment_request: Annotated[Optional[MerchantChannelLabelShipmentRequest], Field(description="The shipment to create")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse:
        """Creates a shipment and initiates shipping label generation

        Marks an order as either fully or partially shipped, based on the order line and quantity input.<br />It also provides the marketplace with information necessary to generate a shipping label.<br />If you make use of multiple stock locations, indicate the **Stock location ID**.<br /> <br />**NB:** to request a shipping label, include information on the package size (i.e.: dimensions and weight).

        :param merchant_channel_label_shipment_request: The shipment to create
        :type merchant_channel_label_shipment_request: MerchantChannelLabelShipmentRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._shipment_create_for_channel_method_serialize(
            merchant_channel_label_shipment_request=merchant_channel_label_shipment_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "ApiResponse",
            '400': "ApiResponse",
            '404': "ApiResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def shipment_create_for_channel_method_with_http_info(
        self,
        merchant_channel_label_shipment_request: Annotated[Optional[MerchantChannelLabelShipmentRequest], Field(description="The shipment to create")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ApiResponse]:
        """Creates a shipment and initiates shipping label generation

        Marks an order as either fully or partially shipped, based on the order line and quantity input.<br />It also provides the marketplace with information necessary to generate a shipping label.<br />If you make use of multiple stock locations, indicate the **Stock location ID**.<br /> <br />**NB:** to request a shipping label, include information on the package size (i.e.: dimensions and weight).

        :param merchant_channel_label_shipment_request: The shipment to create
        :type merchant_channel_label_shipment_request: MerchantChannelLabelShipmentRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._shipment_create_for_channel_method_serialize(
            merchant_channel_label_shipment_request=merchant_channel_label_shipment_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "ApiResponse",
            '400': "ApiResponse",
            '404': "ApiResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def shipment_create_for_channel_method_without_preload_content(
        self,
        merchant_channel_label_shipment_request: Annotated[Optional[MerchantChannelLabelShipmentRequest], Field(description="The shipment to create")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Creates a shipment and initiates shipping label generation

        Marks an order as either fully or partially shipped, based on the order line and quantity input.<br />It also provides the marketplace with information necessary to generate a shipping label.<br />If you make use of multiple stock locations, indicate the **Stock location ID**.<br /> <br />**NB:** to request a shipping label, include information on the package size (i.e.: dimensions and weight).

        :param merchant_channel_label_shipment_request: The shipment to create
        :type merchant_channel_label_shipment_request: MerchantChannelLabelShipmentRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._shipment_create_for_channel_method_serialize(
            merchant_channel_label_shipment_request=merchant_channel_label_shipment_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "ApiResponse",
            '400': "ApiResponse",
            '404': "ApiResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _shipment_create_for_channel_method_serialize(
        self,
        merchant_channel_label_shipment_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if merchant_channel_label_shipment_request is not None:
            _body_params = merchant_channel_label_shipment_request


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json-patch+json', 
                        'application/json', 
                        'application/*+json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'apiKey'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/shipments/channelmethod',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def shipment_get_shipment_label_carriers(
        self,
        merchant_order_no: Annotated[StrictStr, Field(description="The merchant's order reference.")],
        merchant_shipment_label_carrier_request: Annotated[Optional[MerchantShipmentLabelCarrierRequest], Field(description="The parcel information")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CollectionOfMerchantShipmentLabelCarrierResponse:
        """Gets carriers providing shipping labels

        Posts a request to get the available marketplace carrier offers.<br /><br />**NB:** this endpoint is used to buy a shipping label through the marketplace.

        :param merchant_order_no: The merchant's order reference. (required)
        :type merchant_order_no: str
        :param merchant_shipment_label_carrier_request: The parcel information
        :type merchant_shipment_label_carrier_request: MerchantShipmentLabelCarrierRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._shipment_get_shipment_label_carriers_serialize(
            merchant_order_no=merchant_order_no,
            merchant_shipment_label_carrier_request=merchant_shipment_label_carrier_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CollectionOfMerchantShipmentLabelCarrierResponse",
            '400': "ApiResponse",
            '404': "ApiResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def shipment_get_shipment_label_carriers_with_http_info(
        self,
        merchant_order_no: Annotated[StrictStr, Field(description="The merchant's order reference.")],
        merchant_shipment_label_carrier_request: Annotated[Optional[MerchantShipmentLabelCarrierRequest], Field(description="The parcel information")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CollectionOfMerchantShipmentLabelCarrierResponse]:
        """Gets carriers providing shipping labels

        Posts a request to get the available marketplace carrier offers.<br /><br />**NB:** this endpoint is used to buy a shipping label through the marketplace.

        :param merchant_order_no: The merchant's order reference. (required)
        :type merchant_order_no: str
        :param merchant_shipment_label_carrier_request: The parcel information
        :type merchant_shipment_label_carrier_request: MerchantShipmentLabelCarrierRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._shipment_get_shipment_label_carriers_serialize(
            merchant_order_no=merchant_order_no,
            merchant_shipment_label_carrier_request=merchant_shipment_label_carrier_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CollectionOfMerchantShipmentLabelCarrierResponse",
            '400': "ApiResponse",
            '404': "ApiResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def shipment_get_shipment_label_carriers_without_preload_content(
        self,
        merchant_order_no: Annotated[StrictStr, Field(description="The merchant's order reference.")],
        merchant_shipment_label_carrier_request: Annotated[Optional[MerchantShipmentLabelCarrierRequest], Field(description="The parcel information")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Gets carriers providing shipping labels

        Posts a request to get the available marketplace carrier offers.<br /><br />**NB:** this endpoint is used to buy a shipping label through the marketplace.

        :param merchant_order_no: The merchant's order reference. (required)
        :type merchant_order_no: str
        :param merchant_shipment_label_carrier_request: The parcel information
        :type merchant_shipment_label_carrier_request: MerchantShipmentLabelCarrierRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._shipment_get_shipment_label_carriers_serialize(
            merchant_order_no=merchant_order_no,
            merchant_shipment_label_carrier_request=merchant_shipment_label_carrier_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CollectionOfMerchantShipmentLabelCarrierResponse",
            '400': "ApiResponse",
            '404': "ApiResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _shipment_get_shipment_label_carriers_serialize(
        self,
        merchant_order_no,
        merchant_shipment_label_carrier_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if merchant_order_no is not None:
            _path_params['merchantOrderNo'] = merchant_order_no
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if merchant_shipment_label_carrier_request is not None:
            _body_params = merchant_shipment_label_carrier_request


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json-patch+json', 
                        'application/json', 
                        'application/*+json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'apiKey'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/carriers/{merchantOrderNo}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def shipment_index(
        self,
        merchant_shipment_nos: Annotated[Optional[List[StrictStr]], Field(description="Filter on the unique references (ids) as used by the merchant.")] = None,
        merchant_order_nos: Annotated[Optional[List[StrictStr]], Field(description="Filter on the unique references (ids) of order as used by the merchant.")] = None,
        method: Annotated[Optional[StrictStr], Field(description="Filter on the shipping method.")] = None,
        shipped_from_country_codes: Annotated[Optional[List[StrictStr]], Field(description="2-digit Country code")] = None,
        from_shipment_date: Annotated[Optional[datetime], Field(description="Filter on the shipment date, starting from this date. This date is inclusive.")] = None,
        to_shipment_date: Annotated[Optional[datetime], Field(description="Filter on the shipment date, until this date. This date is exclusive.")] = None,
        from_create_date: Annotated[Optional[datetime], Field(description="Filter on the create date of the shipment in ChannelEngine, starting from this date. This date is inclusive.")] = None,
        to_create_date: Annotated[Optional[datetime], Field(description="Filter on the create date of the shipment in ChannelEngine, until this date. This date is exclusive.")] = None,
        from_update_date: Annotated[Optional[datetime], Field(description="Filter on the update date of the shipment in ChannelEngine, starting from this date. This date is inclusive.")] = None,
        to_update_date: Annotated[Optional[datetime], Field(description="Filter on the update date of the shipment in ChannelEngine, until this date. This date is exclusive.")] = None,
        fulfillment_type: Annotated[Optional[ShipmentFulfillmentType], Field(description="Filter on the fulfillment type of the shipment.")] = None,
        channel_shipment_nos: Annotated[Optional[List[StrictStr]], Field(description="Filter on the unique references (ids) as used by the channel.")] = None,
        channel_order_nos: Annotated[Optional[List[StrictStr]], Field(description="Filter on the unique references (ids) of order as used by the channel.")] = None,
        page: Annotated[Optional[StrictInt], Field(description="The page to filter on. Starts at 1.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CollectionOfMerchantShipmentResponse:
        """Gets shipments by filter

        Gets the shipments based on the available filters.<br />Shipments are listed in chronological order, from old to new.

        :param merchant_shipment_nos: Filter on the unique references (ids) as used by the merchant.
        :type merchant_shipment_nos: List[str]
        :param merchant_order_nos: Filter on the unique references (ids) of order as used by the merchant.
        :type merchant_order_nos: List[str]
        :param method: Filter on the shipping method.
        :type method: str
        :param shipped_from_country_codes: 2-digit Country code
        :type shipped_from_country_codes: List[str]
        :param from_shipment_date: Filter on the shipment date, starting from this date. This date is inclusive.
        :type from_shipment_date: datetime
        :param to_shipment_date: Filter on the shipment date, until this date. This date is exclusive.
        :type to_shipment_date: datetime
        :param from_create_date: Filter on the create date of the shipment in ChannelEngine, starting from this date. This date is inclusive.
        :type from_create_date: datetime
        :param to_create_date: Filter on the create date of the shipment in ChannelEngine, until this date. This date is exclusive.
        :type to_create_date: datetime
        :param from_update_date: Filter on the update date of the shipment in ChannelEngine, starting from this date. This date is inclusive.
        :type from_update_date: datetime
        :param to_update_date: Filter on the update date of the shipment in ChannelEngine, until this date. This date is exclusive.
        :type to_update_date: datetime
        :param fulfillment_type: Filter on the fulfillment type of the shipment.
        :type fulfillment_type: ShipmentFulfillmentType
        :param channel_shipment_nos: Filter on the unique references (ids) as used by the channel.
        :type channel_shipment_nos: List[str]
        :param channel_order_nos: Filter on the unique references (ids) of order as used by the channel.
        :type channel_order_nos: List[str]
        :param page: The page to filter on. Starts at 1.
        :type page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._shipment_index_serialize(
            merchant_shipment_nos=merchant_shipment_nos,
            merchant_order_nos=merchant_order_nos,
            method=method,
            shipped_from_country_codes=shipped_from_country_codes,
            from_shipment_date=from_shipment_date,
            to_shipment_date=to_shipment_date,
            from_create_date=from_create_date,
            to_create_date=to_create_date,
            from_update_date=from_update_date,
            to_update_date=to_update_date,
            fulfillment_type=fulfillment_type,
            channel_shipment_nos=channel_shipment_nos,
            channel_order_nos=channel_order_nos,
            page=page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CollectionOfMerchantShipmentResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def shipment_index_with_http_info(
        self,
        merchant_shipment_nos: Annotated[Optional[List[StrictStr]], Field(description="Filter on the unique references (ids) as used by the merchant.")] = None,
        merchant_order_nos: Annotated[Optional[List[StrictStr]], Field(description="Filter on the unique references (ids) of order as used by the merchant.")] = None,
        method: Annotated[Optional[StrictStr], Field(description="Filter on the shipping method.")] = None,
        shipped_from_country_codes: Annotated[Optional[List[StrictStr]], Field(description="2-digit Country code")] = None,
        from_shipment_date: Annotated[Optional[datetime], Field(description="Filter on the shipment date, starting from this date. This date is inclusive.")] = None,
        to_shipment_date: Annotated[Optional[datetime], Field(description="Filter on the shipment date, until this date. This date is exclusive.")] = None,
        from_create_date: Annotated[Optional[datetime], Field(description="Filter on the create date of the shipment in ChannelEngine, starting from this date. This date is inclusive.")] = None,
        to_create_date: Annotated[Optional[datetime], Field(description="Filter on the create date of the shipment in ChannelEngine, until this date. This date is exclusive.")] = None,
        from_update_date: Annotated[Optional[datetime], Field(description="Filter on the update date of the shipment in ChannelEngine, starting from this date. This date is inclusive.")] = None,
        to_update_date: Annotated[Optional[datetime], Field(description="Filter on the update date of the shipment in ChannelEngine, until this date. This date is exclusive.")] = None,
        fulfillment_type: Annotated[Optional[ShipmentFulfillmentType], Field(description="Filter on the fulfillment type of the shipment.")] = None,
        channel_shipment_nos: Annotated[Optional[List[StrictStr]], Field(description="Filter on the unique references (ids) as used by the channel.")] = None,
        channel_order_nos: Annotated[Optional[List[StrictStr]], Field(description="Filter on the unique references (ids) of order as used by the channel.")] = None,
        page: Annotated[Optional[StrictInt], Field(description="The page to filter on. Starts at 1.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CollectionOfMerchantShipmentResponse]:
        """Gets shipments by filter

        Gets the shipments based on the available filters.<br />Shipments are listed in chronological order, from old to new.

        :param merchant_shipment_nos: Filter on the unique references (ids) as used by the merchant.
        :type merchant_shipment_nos: List[str]
        :param merchant_order_nos: Filter on the unique references (ids) of order as used by the merchant.
        :type merchant_order_nos: List[str]
        :param method: Filter on the shipping method.
        :type method: str
        :param shipped_from_country_codes: 2-digit Country code
        :type shipped_from_country_codes: List[str]
        :param from_shipment_date: Filter on the shipment date, starting from this date. This date is inclusive.
        :type from_shipment_date: datetime
        :param to_shipment_date: Filter on the shipment date, until this date. This date is exclusive.
        :type to_shipment_date: datetime
        :param from_create_date: Filter on the create date of the shipment in ChannelEngine, starting from this date. This date is inclusive.
        :type from_create_date: datetime
        :param to_create_date: Filter on the create date of the shipment in ChannelEngine, until this date. This date is exclusive.
        :type to_create_date: datetime
        :param from_update_date: Filter on the update date of the shipment in ChannelEngine, starting from this date. This date is inclusive.
        :type from_update_date: datetime
        :param to_update_date: Filter on the update date of the shipment in ChannelEngine, until this date. This date is exclusive.
        :type to_update_date: datetime
        :param fulfillment_type: Filter on the fulfillment type of the shipment.
        :type fulfillment_type: ShipmentFulfillmentType
        :param channel_shipment_nos: Filter on the unique references (ids) as used by the channel.
        :type channel_shipment_nos: List[str]
        :param channel_order_nos: Filter on the unique references (ids) of order as used by the channel.
        :type channel_order_nos: List[str]
        :param page: The page to filter on. Starts at 1.
        :type page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._shipment_index_serialize(
            merchant_shipment_nos=merchant_shipment_nos,
            merchant_order_nos=merchant_order_nos,
            method=method,
            shipped_from_country_codes=shipped_from_country_codes,
            from_shipment_date=from_shipment_date,
            to_shipment_date=to_shipment_date,
            from_create_date=from_create_date,
            to_create_date=to_create_date,
            from_update_date=from_update_date,
            to_update_date=to_update_date,
            fulfillment_type=fulfillment_type,
            channel_shipment_nos=channel_shipment_nos,
            channel_order_nos=channel_order_nos,
            page=page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CollectionOfMerchantShipmentResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def shipment_index_without_preload_content(
        self,
        merchant_shipment_nos: Annotated[Optional[List[StrictStr]], Field(description="Filter on the unique references (ids) as used by the merchant.")] = None,
        merchant_order_nos: Annotated[Optional[List[StrictStr]], Field(description="Filter on the unique references (ids) of order as used by the merchant.")] = None,
        method: Annotated[Optional[StrictStr], Field(description="Filter on the shipping method.")] = None,
        shipped_from_country_codes: Annotated[Optional[List[StrictStr]], Field(description="2-digit Country code")] = None,
        from_shipment_date: Annotated[Optional[datetime], Field(description="Filter on the shipment date, starting from this date. This date is inclusive.")] = None,
        to_shipment_date: Annotated[Optional[datetime], Field(description="Filter on the shipment date, until this date. This date is exclusive.")] = None,
        from_create_date: Annotated[Optional[datetime], Field(description="Filter on the create date of the shipment in ChannelEngine, starting from this date. This date is inclusive.")] = None,
        to_create_date: Annotated[Optional[datetime], Field(description="Filter on the create date of the shipment in ChannelEngine, until this date. This date is exclusive.")] = None,
        from_update_date: Annotated[Optional[datetime], Field(description="Filter on the update date of the shipment in ChannelEngine, starting from this date. This date is inclusive.")] = None,
        to_update_date: Annotated[Optional[datetime], Field(description="Filter on the update date of the shipment in ChannelEngine, until this date. This date is exclusive.")] = None,
        fulfillment_type: Annotated[Optional[ShipmentFulfillmentType], Field(description="Filter on the fulfillment type of the shipment.")] = None,
        channel_shipment_nos: Annotated[Optional[List[StrictStr]], Field(description="Filter on the unique references (ids) as used by the channel.")] = None,
        channel_order_nos: Annotated[Optional[List[StrictStr]], Field(description="Filter on the unique references (ids) of order as used by the channel.")] = None,
        page: Annotated[Optional[StrictInt], Field(description="The page to filter on. Starts at 1.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Gets shipments by filter

        Gets the shipments based on the available filters.<br />Shipments are listed in chronological order, from old to new.

        :param merchant_shipment_nos: Filter on the unique references (ids) as used by the merchant.
        :type merchant_shipment_nos: List[str]
        :param merchant_order_nos: Filter on the unique references (ids) of order as used by the merchant.
        :type merchant_order_nos: List[str]
        :param method: Filter on the shipping method.
        :type method: str
        :param shipped_from_country_codes: 2-digit Country code
        :type shipped_from_country_codes: List[str]
        :param from_shipment_date: Filter on the shipment date, starting from this date. This date is inclusive.
        :type from_shipment_date: datetime
        :param to_shipment_date: Filter on the shipment date, until this date. This date is exclusive.
        :type to_shipment_date: datetime
        :param from_create_date: Filter on the create date of the shipment in ChannelEngine, starting from this date. This date is inclusive.
        :type from_create_date: datetime
        :param to_create_date: Filter on the create date of the shipment in ChannelEngine, until this date. This date is exclusive.
        :type to_create_date: datetime
        :param from_update_date: Filter on the update date of the shipment in ChannelEngine, starting from this date. This date is inclusive.
        :type from_update_date: datetime
        :param to_update_date: Filter on the update date of the shipment in ChannelEngine, until this date. This date is exclusive.
        :type to_update_date: datetime
        :param fulfillment_type: Filter on the fulfillment type of the shipment.
        :type fulfillment_type: ShipmentFulfillmentType
        :param channel_shipment_nos: Filter on the unique references (ids) as used by the channel.
        :type channel_shipment_nos: List[str]
        :param channel_order_nos: Filter on the unique references (ids) of order as used by the channel.
        :type channel_order_nos: List[str]
        :param page: The page to filter on. Starts at 1.
        :type page: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._shipment_index_serialize(
            merchant_shipment_nos=merchant_shipment_nos,
            merchant_order_nos=merchant_order_nos,
            method=method,
            shipped_from_country_codes=shipped_from_country_codes,
            from_shipment_date=from_shipment_date,
            to_shipment_date=to_shipment_date,
            from_create_date=from_create_date,
            to_create_date=to_create_date,
            from_update_date=from_update_date,
            to_update_date=to_update_date,
            fulfillment_type=fulfillment_type,
            channel_shipment_nos=channel_shipment_nos,
            channel_order_nos=channel_order_nos,
            page=page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CollectionOfMerchantShipmentResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _shipment_index_serialize(
        self,
        merchant_shipment_nos,
        merchant_order_nos,
        method,
        shipped_from_country_codes,
        from_shipment_date,
        to_shipment_date,
        from_create_date,
        to_create_date,
        from_update_date,
        to_update_date,
        fulfillment_type,
        channel_shipment_nos,
        channel_order_nos,
        page,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'merchantShipmentNos': 'multi',
            'merchantOrderNos': 'multi',
            'shippedFromCountryCodes': 'multi',
            'channelShipmentNos': 'multi',
            'channelOrderNos': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if merchant_shipment_nos is not None:
            
            _query_params.append(('merchantShipmentNos', merchant_shipment_nos))
            
        if merchant_order_nos is not None:
            
            _query_params.append(('merchantOrderNos', merchant_order_nos))
            
        if method is not None:
            
            _query_params.append(('method', method))
            
        if shipped_from_country_codes is not None:
            
            _query_params.append(('shippedFromCountryCodes', shipped_from_country_codes))
            
        if from_shipment_date is not None:
            if isinstance(from_shipment_date, datetime):
                _query_params.append(
                    (
                        'fromShipmentDate',
                        from_shipment_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('fromShipmentDate', from_shipment_date))
            
        if to_shipment_date is not None:
            if isinstance(to_shipment_date, datetime):
                _query_params.append(
                    (
                        'toShipmentDate',
                        to_shipment_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('toShipmentDate', to_shipment_date))
            
        if from_create_date is not None:
            if isinstance(from_create_date, datetime):
                _query_params.append(
                    (
                        'fromCreateDate',
                        from_create_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('fromCreateDate', from_create_date))
            
        if to_create_date is not None:
            if isinstance(to_create_date, datetime):
                _query_params.append(
                    (
                        'toCreateDate',
                        to_create_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('toCreateDate', to_create_date))
            
        if from_update_date is not None:
            if isinstance(from_update_date, datetime):
                _query_params.append(
                    (
                        'fromUpdateDate',
                        from_update_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('fromUpdateDate', from_update_date))
            
        if to_update_date is not None:
            if isinstance(to_update_date, datetime):
                _query_params.append(
                    (
                        'toUpdateDate',
                        to_update_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('toUpdateDate', to_update_date))
            
        if fulfillment_type is not None:
            
            _query_params.append(('fulfillmentType', fulfillment_type.value))
            
        if channel_shipment_nos is not None:
            
            _query_params.append(('channelShipmentNos', channel_shipment_nos))
            
        if channel_order_nos is not None:
            
            _query_params.append(('channelOrderNos', channel_order_nos))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'apiKey'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/shipments/merchant',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def shipment_shipping_label(
        self,
        merchant_shipment_no: Annotated[StrictStr, Field(description="The unique shipment reference as used by the merchant.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> bytearray:
        """Gets a shipping label

         Downloads the shipping label for the shipment.<br /> <br /> **NB:** it may take some time between the creation of the shipment and the availability of the label.<br />A \"404 not found\" error might indicate that the label is not available yet.

        :param merchant_shipment_no: The unique shipment reference as used by the merchant. (required)
        :type merchant_shipment_no: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._shipment_shipping_label_serialize(
            merchant_shipment_no=merchant_shipment_no,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '404': "ApiResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def shipment_shipping_label_with_http_info(
        self,
        merchant_shipment_no: Annotated[StrictStr, Field(description="The unique shipment reference as used by the merchant.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[bytearray]:
        """Gets a shipping label

         Downloads the shipping label for the shipment.<br /> <br /> **NB:** it may take some time between the creation of the shipment and the availability of the label.<br />A \"404 not found\" error might indicate that the label is not available yet.

        :param merchant_shipment_no: The unique shipment reference as used by the merchant. (required)
        :type merchant_shipment_no: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._shipment_shipping_label_serialize(
            merchant_shipment_no=merchant_shipment_no,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '404': "ApiResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def shipment_shipping_label_without_preload_content(
        self,
        merchant_shipment_no: Annotated[StrictStr, Field(description="The unique shipment reference as used by the merchant.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Gets a shipping label

         Downloads the shipping label for the shipment.<br /> <br /> **NB:** it may take some time between the creation of the shipment and the availability of the label.<br />A \"404 not found\" error might indicate that the label is not available yet.

        :param merchant_shipment_no: The unique shipment reference as used by the merchant. (required)
        :type merchant_shipment_no: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._shipment_shipping_label_serialize(
            merchant_shipment_no=merchant_shipment_no,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '404': "ApiResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _shipment_shipping_label_serialize(
        self,
        merchant_shipment_no,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if merchant_shipment_no is not None:
            _path_params['merchantShipmentNo'] = merchant_shipment_no
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/vnd.shippingLabel', 
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'apiKey'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/orders/{merchantShipmentNo}/shippinglabel',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def shipment_update(
        self,
        merchant_shipment_no: Annotated[StrictStr, Field(description="The merchant's shipment reference.")],
        merchant_shipment_tracking_request: Annotated[Optional[MerchantShipmentTrackingRequest], Field(description="The updated tracking information.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse:
        """Updates a shipment

        Updates an existing shipment with tracking information and shipping method.

        :param merchant_shipment_no: The merchant's shipment reference. (required)
        :type merchant_shipment_no: str
        :param merchant_shipment_tracking_request: The updated tracking information.
        :type merchant_shipment_tracking_request: MerchantShipmentTrackingRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._shipment_update_serialize(
            merchant_shipment_no=merchant_shipment_no,
            merchant_shipment_tracking_request=merchant_shipment_tracking_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApiResponse",
            '400': "ApiResponse",
            '404': "ApiResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def shipment_update_with_http_info(
        self,
        merchant_shipment_no: Annotated[StrictStr, Field(description="The merchant's shipment reference.")],
        merchant_shipment_tracking_request: Annotated[Optional[MerchantShipmentTrackingRequest], Field(description="The updated tracking information.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ApiResponse]:
        """Updates a shipment

        Updates an existing shipment with tracking information and shipping method.

        :param merchant_shipment_no: The merchant's shipment reference. (required)
        :type merchant_shipment_no: str
        :param merchant_shipment_tracking_request: The updated tracking information.
        :type merchant_shipment_tracking_request: MerchantShipmentTrackingRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._shipment_update_serialize(
            merchant_shipment_no=merchant_shipment_no,
            merchant_shipment_tracking_request=merchant_shipment_tracking_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApiResponse",
            '400': "ApiResponse",
            '404': "ApiResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def shipment_update_without_preload_content(
        self,
        merchant_shipment_no: Annotated[StrictStr, Field(description="The merchant's shipment reference.")],
        merchant_shipment_tracking_request: Annotated[Optional[MerchantShipmentTrackingRequest], Field(description="The updated tracking information.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Updates a shipment

        Updates an existing shipment with tracking information and shipping method.

        :param merchant_shipment_no: The merchant's shipment reference. (required)
        :type merchant_shipment_no: str
        :param merchant_shipment_tracking_request: The updated tracking information.
        :type merchant_shipment_tracking_request: MerchantShipmentTrackingRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._shipment_update_serialize(
            merchant_shipment_no=merchant_shipment_no,
            merchant_shipment_tracking_request=merchant_shipment_tracking_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApiResponse",
            '400': "ApiResponse",
            '404': "ApiResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _shipment_update_serialize(
        self,
        merchant_shipment_no,
        merchant_shipment_tracking_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if merchant_shipment_no is not None:
            _path_params['merchantShipmentNo'] = merchant_shipment_no
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if merchant_shipment_tracking_request is not None:
            _body_params = merchant_shipment_tracking_request


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json-patch+json', 
                        'application/json', 
                        'application/*+json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'apiKey'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/v2/shipments/{merchantShipmentNo}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


